<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
   <TITLE>10.Timers/Interrupts</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffff" LINK="#FF0000" VLINK="#800000" ALINK="#00FF00" FGCOLOR="#000000">
<A NAME = "TOP">
<H1 ALIGN=CENTER><U>10.Timers/Interrupts</U></H1>
</A>
<p><A HREF ="irq.html">More info ...</A><P>
<OL>
<P><A NAME = "_101"><A HREF = "#TOP">
<LI>Timers</A></A>
<P>
There are 8 independent timers. Each has the same construction as an audio 
channel, a 3 bit source period selector and an 8 bit down counter with a backup 
register. This gives a timer range of 1 us to 16384 us. Timers can be set to stop when 
they reach a count of 0 or to reload from their backup register. In addition, they can be 
linked, with the reload of one timer clocking the next timer.<BR>
 The linking order is as follows:
<P>
 Group A:<BR>
 Timer 0 -> Timer 2 -> Timer 4. 
<P>
 Group B:<BR>
 Timer 1 -> Timer 3 -> Timer 5 -> Timer 7 -> Audio 0 -> Audio 1-> Audio 2 -> 
Audio 3 -> Timer 1. 
<P>
As with the audio channels, a count of 0 is valid for 1 full cycle of the selected clock. A 
backup value of 5 will result in 6 units of time. Actually, dve to hardware limitations, the 
first utilization of that timer after it has been set will result in a time vafue between 5 
and 6 units. Subsequent utilizations (reload is 'on') will result in a value of 6 units. 
<P><A NAME = "_102"><A HREF = "#TOP"> 
<LI>Timer Utilization</A></A>
<P>
Two of the timers wiil be used for the video frame rate generator. One (timer 0) is set 
to the length ot a display line and the second (timer 2) is set to the number of lines. 
One of the timers (timer 4) will be used as the baud rate generator for the serial 
expansion port (UART).
<P>
Note that the hardware actually uses the bits in these timers and it would be 
dangerous to arbitrarily fiddle with them in software.
The other 5 timers are for general software use. POOF. See the mag tape 
description. 
<P><A NAME ="_103"><A HREF = "#TOP"> 
<LI>Interrupts</A></A>
<P>
7 of the 8 timers can interrupt the CPU when it underflows. Each interrupt can be 
masked. The value of the interrupt bit can be polled independent of its mask condition. 
The interrupt bit for timer 4 (UART baud rate) is driven by receiver or transmitter ready 
bit of the UART.
<P>
If an interrupt occurs while the CPU is asleep, it will wake up the CPU. Since one of 
the timers is the vertical line counter, the useful 'end of frame' interrupt can be 
generated there.
<P>
The interrupt signal comes from the timer when the timer value is zero AND the timer 
is attempting to perform a 'borrow'. Based on the control bits, the borrow may not 
actually occur, but the interrupt signal will. This signal then reqvests the bus control 
circuit to give the bus to the CPU. If the CPU already has the bus, then this function 
causes no delays. If Suzy has the bus, then the maximum Suzy latency time could be 
incurred. Then, the interrupt signal waits for the end of the current CPU cycle before 
actually interrupting the CPU.
</OL>
<P>
<B>[<a href="lynx7.html#_9">BACK</a>|<a href="lynxdoc.html">CONTENTS</a>|<a
href="#_11">NEXT</A>]</B>
<P>
<!---------------------------------------------------------------------------->
<P>
<A NAME = "_11">
<H1 ALIGN=CENTER><U>11.UART</U></H1>
</A>
<OL>
<P>
The Mikey UART is a pretty standard serial kind of thing. However, since most of the 
communicating world has managed lo bolix up the definitions and use of the so- called 
standards of serial communications, I will attempt to explain all of our UARTs 
functions. Yes, I will leave something out so as to continue to trick earthlings into 
thinking that I am human.
<P><A NAME = "_111"><A HREF ="#_11">
<LI>Connector Signals</A></A>
<P>
The UART connects to the REDEYE connector which has pins. There is 1 data pin. 
This signal is bi-directional serial data. Its idle state is open-collector with a pull- up 
resistor to +5. There is one ground pin, and one VCC pin. 
<P>
(A design error causes the power up state of the output to be TTL high, ALL code 
must set the TXOPEN bit in order to fix this. Its not my fault.) 
<P>
There is also a signal called NOEXP which indicates the presence of a plug in the 
REDEYE socket.
<P>
Any devices other than RedEye will need to have an intelligent protocol to distinguish 
themselves from a RedEye type device. See the RedEye specification for protocol 
details. 
<P><A NAME = "_112"><A HREF ="#_11">
<LI>Baud Rate</A></A> 
<P>
The baud rate is generated by TIMER4 according to the equation
<P>
CLOCK4 / (TIMER4 + 1) / 8 
<P>
The minimum number that can be used in TIMER4 is 1, the maximum number is 255. 
The fastest CLOCK4 is 1MHz, the slowest is 15625 Hz. This gives a baud rate 
maximum of 62.5 Kbaud and a minimum of 7.63 baud. The settings for the common 
baud rates are: 
<P>
<PRE>
BaudRate CLOCK4 TIMER4 Actual 
62500    1us    1      62500 
9600     1us    12     9615 
2400     1us    51     2404 
1200     1us    103    1202 
300      2us    207    300.5 
</PRE>
<P><A NAME = "_113"><A HREF ="#_11">
<LI>Data Format</A></A>
<p>
The serial data format is the standard 11 bits. We do not offer a choice.
<P>
The standard bits are:
<p>
<DL>
 <Dd>1 start bit (binary 0);<BR>
 <Dd>8 data bits, LSB first;<BR>
 <Dd>1 parity bit (or 9th bit as defined by the control byte);<BR>
 <Dd>1 stop bit (binary 1).
</DL>
<P> 
The parity (or 9th) bit operates as follows:
<P>
<DL>
<DT>Receive:<BR>
<DD> The state of the 9th bit is always available for read in the control byte. In addition, the 
parity of the received character is calculated and if it does not match the setting of the 
parity select bit in the control byte, the parity error bit will be set. Receive parity error 
can not be disabled. If you don't want it, don't read it. 
<P>
<DT>Transmit:<BR>
<DD>The 9th bit is always sent. It is either the result of a parity calculation on the 
transmit data byte or it is the value set in the parity select bit in the control register.
<BR>The choice is made by the parity enable bit in the control byte. For
exampel :<BR>
<PR>
 If PAREN is '1' and PAREVEN is '0', then the 9th bit will be the result of an 'odd' parity 
calculation on the transmit data byte.<BR>
 If PAREN is '0', then the 9th bit will be whatever the state of PAREVEN is.
<P>
</DL>
 We have just discovered that the calculation for parity includes the parity bit itself. 
Most of us don't like that, but it is too late to change it. 
<P><A NAME = "_114"><A HREF ="#_11">
<LI>Break</A></A>
<P>
A break of any length can be transmitted by setting the transmit break bit in the control 
register. The break will continue as long as the bit is set.<BR>
 A 'break' is defined as a start bit, a data value of 0 (same as a permanent start bit), 
and the absence of a stop bit at the expected time.<BR>
 The receiver requires that a break lasts 24 bit times before it is recognized. There are 
many 'standard' break lengths, this is the one we chose.
<P>
<A NAME = "_115"><A HREF ="#_11">
<LI>Transmitter Status Bits</A></A>
<P>
There are 2 status bits for the transmitter, TXRDY (transmit bvffer ready) and 
TXEMPTY (transmitter totally done).<BR>
 If TXRDY is a '1', then the contents of the transmit holding register have been loaded 
into the transmit shift register and the holding register is now available to be loaded 
with the next byte to be transmitted. This bit is also set to '1' after a reset.
 If TXEMPTY is a '1', then BOTH the transmit holding register and the transmit shift 
register have been emptied and there are no more bits going out the serial data line. 
<P>
<A NAME = "_116"> <A HREF ="#_11">
<LI>Errors</A></A>
<P> 
There are 3 receive errors, parity error (atready explained), framing error, and overrun 
error. Once received, these error bits remain set until they are cleared by writing to the 
control byte with the reset error bit set. Writing to the control byte with the reset error 
bit cleared has no effect on the errors. Note that the reset error bit is NOT an error 
enable bit. Receive errors are always enabled.<BR>
 Framing error indicates that a non-zero character has been received without the 
appropriate stop bit.<BR>
 Overrun error indicates that a character (of any kind or error) has been received and 
the previously received character has not yet been read from the receive buffer. 
<P>
<A NAME = "_117"> <A HREF ="#_11">
<LI>Unusual Interrupt Condition</A></A>
<P>
 Well, we did screw something up after all. Both the transmit and receive interrupts 
are 'level' sensitive, rather than 'edge' sensitive. This means that an interrupt will be 
continuously generated as long as it is enabled and its UART buffer is ready. As a 
result, the software must disable the interrupt prior to clearing it.<BR>
 Sorry. 
<P>
<A NAME = "_118"><A HREF ="#_11">
<LI>left out</A></A>
<P>
I left something out. I know what it is but by the next time I revise this spec, I may have 
forgotten. 
<p>.
<P>..
<P>...
<P>
I have forgotten. 

<P>
<B>[<a href="lynx8.html#TOP">BACK</a>|<a href="lynxdoc.html">CONTENTS</a>|<a
href="lynx9.html">NEXT</A>]</B>
<P>

<P>
<HR NOSHADE><FONT SIZE=-2><A HREF="../index.html#TOP">HOME<BR>
<ADRESS><A HREF="mailto:elw5basc@rghx50.gp.fht-esslingen.de">(c) Bastian
Schick</A>
<BR>last modified 1995/12/16</FONT></P>

</BODY>
</HTML>
